start: program
program: statement*

statement: declaration
         | definition
         | ifthenelse
         | while
         | return
         | func_call ";"


?expression: neg
           | func_call
          
?neg: sum
          
?sum: prod
    | sum "+" prod -> add
    | sum "-" prod -> sub

?prod: factor
     | prod "*" atom -> mul
     | prod "/" atom -> div
     | prod "%" atom -> mod 

?factor: atom
       | "!" factor -> not
       | "-" factor -> neg


?declaration: binder func_args ";" -> funcdec
            | binder";" -> vardec

?definition: "main:Void" func_args block  -> main
           | binder func_args block -> funcdef
           | [binder|var] "=" expression ";" -> vardef 

?comparison: expression CMP_OP expression

?condition: comparison
         | var
         | comparison LOG_OP condition

func_call: NAME"("(expression ["," expression ]*)?")"


ifthenelse: "if" condition block ["else" block]
while: "while" condition block 

return: "return" [expression] ";"

refinement: "where" condition

func_args: "("(binder ["," binder]* )?")"

block: "{" statement* "}"

var: NAME
binder: NAME":"type refinement?

?atom: INT
     | FLOAT
     | TRUE
     | FALSE
     | var
     | STRING
     | NAME "["atom"]" -> index_access
     // | "("expression")" Parenthesized expression are part of this language?

?type: TYPE
     | "["type"]" -> arrayof




// Special declarations of terminals not in common.lark
LOG_OP: "&&" | "||"  
ADD_OP:  "+" | "-" 
MUL_OP: "*"  | "/"  | "%"
CMP_OP: "==" | "!=" | ">=" | ">" | "<" | "<="
UNOP: "!" | "-"

INT: /((_*)?\d+)+/
FLOAT: DIGIT+ | DIGIT*"."DIGIT+ 

TYPE: "Int" | "Float" | "Double" | "Bool" | "String" | "Void"

TRUE: "true" 
FALSE: "false"


// NAME (alias for common.CNAME) describes our variable format  
// INDEX_ACCESS: NAME"["INT"]" 

//  MISC
COMMENT: "(*" /(.|\n)*?/ "*)" // Match any comments multiline

%import common.WS
%ignore WS
%import common.WS_INLINE
%ignore WS_INLINE

%ignore COMMENT

%import common.CNAME -> NAME
%import common.ESCAPED_STRING -> STRING
%import common.DIGIT





